_code segment
	assume  cs:_code

start:	mov	ax, _data
	mov	ds, ax
	assume	ds:_data
	mov	ax, _stack
	mov	ss, ax
	assume	ss:_stack
	mov	sp, top_stack
	
	mov cx,6d				; LICZNIK DLA DLUGOSCI WPROWADZANEGO SLOWA
	mov dx, offset indata	; WSKAZANIE MIEJSCA W DS TEKSTU PODAJ LICZBE
	mov ah,09h				; FUNKCJA WYPISUJACA TEKST
	int 21h					; WYWOLANIE PRZERWANIA KTORE WYSWIETLI TEKST PODAJ LICZBE
	mov dx,0 				; WYZEROWANIE REJESTRU DX
	
INPUT:    
	mov ah,08h				; FUNKCJA CZYTANIA ZNAKU
	int 21h					; FUNKCJA CZEKA NA ZNAK A NASTEPNIE ZAPISUJE GO W AL
	mov dl,al				; PRZENIESIENIE ZNAKU DO DL
	cmp dl,13				; POROWNANIE CZY LICZBA JEST ENTEREM, USTAWIENIE FLAGI ZERA
	JE ENT					; JESLI ENETER TO PRZEJDZ DO ETYKIETY, JESLI Z=1!
	cmp dl,8d				; POROWNANIE CZY ZOSTAL KLIKNIETY BACKSPACE
	JE BACKSP				; JESLI TAK PRZEJDZ DO ETYKIETY BACKSPACE, JESLI Z=1!
	mov ah,02h				; FUNKCJA WYPISUJACA ZNAK
	int 21h					; WYPISUJE ZNAK W KONSOLI ZNAJDUJACY SIE W REJESTRZE DL
	cmp cx,6				; SPRAWDZAMY CZY TO PIERWSZY ZNAK KTORY ODPOWIDA CZY JEST TO LICZBA DODATNIA LUB UJEMNA
	JE SIGN					; JESLI TAK PRZEJDZ DO ETYKIETY SIGN, JESLI Z=1!
	MOV ax,dx				; PRZENISIENIE ZAWARTOSCI DX DO AX
	STOSB					; PRZESYLA DANE Z AL (bajt) DO MIEJSCA W ES:DI, FLAG D=0 ZWIEKSZA DI, D=1 ZMNIEJSZA
	LOOP INPUT				; ZMNIEJSZA ZAWARTOSC CX O 1, JESLI CX ROZNY OD 0 PRZEJDZ DO ETYKIETY
INIT:
	mov bx,0				; TU BEDZIEMY PRZECHOWYWAC OBLICZONA LICZBE
	mov cx,1				; TU BEDZIEMY PRZECHOWYWAC WARTOSC POTEGI
	dec di					; USTAWIAMY WARTOSC INDEKSU NA OSTATNI ZNAK
	mov si,di				; USTAWIENIE REJESTRU INDEKSOWEGO SI NA OSTATNI POBRANY ZNAK
	mov ax,ES:[SI]			; POBRANIE PIERWSZEGO ZNAKU OD KONCA
SUM:
	mov ah,0				; ZEROWANIE AH
	SUB	al,48d				; ZAMIANA ASCII NA LICZBE
	CMP al,10d				; SPRAWDZENIE CZY 0-9 WIEKSZE ZNAKI, BEDZIEMY ROBIC SKOK GDY NIE WIEKSZE NIZ 10
	JGE ERR					; JESLI INNA NIZ DEC PRZEJDZ DO WYSWIELENIA BLEDU / (S xor O) = 0, SKOK DO ETYKIETY JESLI FLAGA S = 0 
	CMP al,0d				; SPRAWDZENIE CZY 0-9 MNIEJSZE ZNAKI
	JL ERR					; SKOK DO ETYKIETY GDY MNIEJSZY, FLAG S = 0
	MUL cx					; PRZEMNOZENIE ZALEZNIE OD POZYCJI, WYNIK W AX DLA OPERACJI 8 BIT, MNOZYMY AX CX, JESLI PRZEPELNIENIE USTAWIA C, WYNIK JEST W AX(MLODSZE BITY) I DX(STARSZE BITY), FLAGE O TEZ USTAWIA 
	JO ERR					; JESLI FLAG O - OVERFLOW ZOSTANIE USTAWIONA TO SKOK DO ETYKIETY, W NASZY PRZYPADKU KIEDY NASTAPI PRZEPELNINIE
	ADD bx,ax				; SUMOWANIE LICZBY 10
	JC ERR 					; JESLI NADWYZKA WYSWIETL BLAD
	mov ax,cx				; MNOZENIE 1 -> 10 -> 100 -> ...
	mov dx,10d				
	MUL dx					; W AX KOLEJNA POTEGA 10
	mov cx,ax				; ZAPISANIE WARTOSCI POTEGI 10 W REJESTRZE
	dec si					; INDEKS KOLEJNEGO ZNAKU 
	mov ax,ES:[SI]			; POBRANIE KOLEJNEGO ZNAKU
	cmp al,'-'
	JE MINNB				; PRZERWANIE PETLI I PRZEJSCIA DO ETYKIETY GDZIE SA WYKOONYWNE OPERACJE DLA LICZBY UJEMNEJ, Z=1!
	cmp al,'+'
	JE PLUS					; PRZERWANIE PETLI I PRZEJSCIA DO ETYKIETY GDZIE SA WYKONYWNE OPERACJE DLA LICZBY DODATNIEJ
	nop						; ODPOWIADA ZA WYROWANIE CYKLI ZEGAROWYCH CO POZWALA UNIKNAC BLEDU 'SKOKOW PRZEZ CIEN'
	JMP SUM					; BEZPOSREDNIE PRZEJSCIE DO KOLEJNEJ OPERACJI, SKOK DO ETYKIETY SUM
SHOW:
	CMP SI,0d				; SPRAWDZENIE CZY ODCZYTALISMY WSZYSTKIE ZNAKI
	JNZ ERR					; SKOK GDY NIE ZERO, FlAGA Z=0!
	CALL SBINARY			
	CALL SHOWHEX
	JMP STOP
BACKSP:
	cmp di,0				; KIEDY NIE POBRALISMY JESZCZE ZADNEGO ZNAKU
	JE INPUT				; WRACAMY DO WPROWADZANIA, Z=1
	CALL PRINTBS			; USUWAMY ZNAK W KONSLI
	dec di					; COFAMY SIE O ZNAK W LEWO W KONSOLI
	mov dx,ES:[di]-1		; PRZENOSIMY DO DX OSTATNIE 2 ZNAKI
	cmp dl,'+'				; SPRAWDZENIE CZY PLUS
	JNE INPUT				; JESLI NIE, Z=0 WROC DO WPROWADZANIA
	dec di					
	ADD CX,1				
	JMP INPUT				; WROC DO WPROWADZANIA
ENT:						; OBSLUGA PIERWSZEGO ENTERa
	cmp cx,5
	JBE INIT				; PONIZEJ LUB ROWNO, KIEDY KLIKNIETO ENTER, C=1 LUB Z=1 TO SKOK
	JMP ERR					; JESLI PUSTE SLOWO TO PRZEJDZ DO BLEDU
ERR:						; OBSLUGA NIEPRAWIDLOWYCH DANYCH
	mov dx, offset blad		; WYSWIETLENIE KOMUNIKATU BLEDU
	mov ah,09h				; WYSWIETLENIE KOMUNIKATU AZ DO ZNAKU '$'
	int 21h
	JMP STOP				; PRZEJDZ DO KONCA PROGRAMU
SIGN:	
	cmp dl,'-'
	JE MINUS				; ZNAK JESLI BEDZIE TO LICZBA UJEMNA
	MOV AX,'+'				; BEDZIEMY USTAWIAC ZNAK DLA LICZBY DODATNIEJ
	STOSB					; PRZESYLA DANE Z AL (bajt) DO MIEJSCA W ES:DI, FLAG D=0 ZWIEKSZA DI, D=1 ZMNIEJSZA
	MOV AX,DX	
	STOSB					; ZAPISANIE PIERWSZEJ CYFRY PO ZNAKU
	sub cx,2d				; Zmniejszenie o 2, poniewaz nie bedziemy wypisywac plusa
	JMP INPUT
MINNB:
	cmp bx,32768d 			; Liczba ujemna nie moze przekraczac 32768
	JA ERR					; BADANIE C=0 AND Z=0 
CONV:
	NOT bx					; Konwersja poprzez negacje wszystkich bitow
	ADD bx,1d				; Uzupelnienie do 2
	JMP SHOW 
PLUS:						; SPRAWDZENIE CZY WIEKSZE NIZ 32767
	cmp bx,32767d 			
	JA ERR					; SKOK GDY WIEKSZY, MUSZA BYC USTWIONE FLAGI C=0 i Z=0
	JMP SHOW
MINUS:
	MOV AX,'-'
	STOSB					; ZAPISANIE ZNAKU, PRZESYLA DANE Z AL (bajt) DO MIEJSCA W ES:DI, FLAG D=0 ZWIEKSZA DI, D=1 ZMNIEJSZA
	DEC cx					; Zmniejszenie, aby przejsc do kolejnej iteracji
	JMP INPUT
PRINTBS:
	ADD CX,1				;	USUWANIE LITERY BACKSPACE -> PUSTY ZNAK -> BACKSPACE
	mov dl,8d			
	mov ah,02h				; WYPISUJE ZNAK Z DL
	int 21h	
	mov dl,' '
	int 21h
	mov dl,8d
	int 21h
	ret
STOP:
	mov	ah, 4ch
	mov	al, 0
	int	21h

;*****************************************SHOW BINARY(){
;WYPISANIE BINARNE OD NAJSTARSZEGO BIT DO NAJMLODSZEGO
SBINARY:
	mov dx, offset binTekst		; WYSWIETLENIE TEKSTU
	mov ah,09h
	int 21h
	clc            				; WYZEROWANIE FLAGI C
	xor ax,ax					; WYZEROWANIE REJESTRU ax
	xor dx,dx					; WYZEROWANIE REJESTRU dx
	push bx						; ZACHOWANIE NA STOSIE POLICZONEJ LICZBY 10
	mov cx,16d					; LICZBA ITERACJI
LOOPBIN:
	mov dl,'0'					; DOMYSLNIE WYSWIETL 0
	rcl bx,1d					; OBROT W LEWO Z BITEM CARRY, WARTOSC C JEST PRZEKAZYWANA DO PIERWSZEGO BITU OBRACANEGO BAJTU, A WARTOSC OSTATNIEGO BAJTU DO FLAGI C
	jnc SKIPONE					; JESLI C=0, ZOSTAJE DOMYSLNIE WYSWIETLONE 0, SKOK DO ETYKIETY KIEDY C=0
	mov dl,'1'					; W PRZECIWNYM RAZIE USTAW DO WYSWIETLENIA 1
SKIPONE:
	mov ah,02h					; FUNKCJA DO WYSWIETLENIA ZNAKU
	int 21h
	loop LOOPBIN				; POWTARZAJ PETLE 16 razy
	pop bx						; NA ZAKONCZENIE PRZYWROC POLICZONA LB 10
	ret							; POWROT
;********************************************}

;**********************************************SHOWHEX{
SHOWHEX:
	mov dx, offset hexTekst		; WYSWIETLANIE TEKSU
	mov ah,09h
	int 21h
	push bx        				; UMIESZCZENIE LICZBY NA STOS
	mov di,0d      				; LICZBA ITERACJI PETLI
	mov cl,12d     				; USTAWIENIE LICZBY PRZESUNIEC
DIVPETLA:
	shr bx,cl      				; PRZESUNIECIE LOGICZNE W PRAWO CL RAZY, ABY LICZBA NIE PRZEKRACZALA 16
	mov dx,bx					; PRZECHOWANIE PRZESUNIETEJ LICZBY W DX, DO WYSWIETLENIA
	call WYS					; WYSWIETLANIE AKTUALNEJ CZESCI LICZBY
	shl bx,cl					; PRZESUNIECIE LOGICZNE W LEWO, DZIEKI CZEMU LICZBA MA PODOBNA POSTAC: XXXX00000000 -> 0000XXXX00000000 -> ... , NA NAJMLODSZA POZYCJE TRAFIA ZERO
	pop dx						; POLICZONA WCZESNIEJ LICZBA
	sub dx,bx					; ODJECIE OD POLICZONEJ LICZBY, CZESCI JUZ WYSWIETLONEJ (np: 0000101011011111 - 0000101000000000)
	mov bx,dx					; ZAPISANIE WYNIKU
	push bx						

	sub cl,4d      				; KOLEJNA ITERACJA WYKONA O 4 MNIEJ PRZESUNIEC
	inc di         				; ZWIEKSZENIE ITERACJI
	cmp di,4d      				
	jc DIVPETLA					; POWTARZAJ PETLE 4 RAZY
	pop bx						; POBRANIE ZE STOSU LICZBY, ABY ZOSTAL ADRES POWROTU
	ret

WYS:
	add dx,48d					; DODANIE 48, ABY WYSWIETLIC LICZBE W ASCII
	cmp dx,58d					; SPRAWDZENIE CZY LICZBA JEST MNIEJSZA OD 10
	jc SKIPLETTER				; JESLI JEST MNIEJSZA POMIN DODAWANIE
	add dx,7d					; DODAJ 7 ABY WYSWIETLALO A-F W ASCII
SKIPLETTER:
	mov ah,02h					; WYSWIETL ZNAK ZAPISANY W DL
	int 21h
	ret
;***********************************************}

_code ends

_data segment
	indata db 'Podaj liczbe:$'
	blad db 10,13,'Nieprawidlowe dane',10,13,'$'
	binTekst db 10,13,'Liczba binarnie: $'
	hexTekst db 10,13,'Liczba heksadecymalnie: $'
_data ends

_stack segment stack
	top_stack	equ 100h
_stack ends

end start